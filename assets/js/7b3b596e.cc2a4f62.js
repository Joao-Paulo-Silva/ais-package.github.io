"use strict";(self.webpackChunkais_project_github_io=self.webpackChunkais_project_github_io||[]).push([[7861],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>f});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=c(n),m=r,f=u["".concat(s,".").concat(m)]||u[m]||d[m]||i;return n?a.createElement(f,l(l({ref:t},p),{},{components:n})):a.createElement(f,l({ref:t},p))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[u]="string"==typeof e?e:r,l[1]=o;for(var c=2;c<i;c++)l[c]=n[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3537:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const i={sidebar_position:1,title:"Artificial Immune Recognition System Base",sidebar_label:"Artificial Immune Recognition System",lastUpdatedAt:"2025/04/07",author:"Jo\xe3o Paulo"},l="BaseClassifier",o={unversionedId:"advanced-guides/Base Classes Reference/csa/Classifier",id:"version-0.2.x/advanced-guides/Base Classes Reference/csa/Classifier",title:"Artificial Immune Recognition System Base",description:"The BaseClassifier class contains utility functions with the protected modifier that can be inherited by various classes for ease of use. It includes functions for distance calculation, data separation to improve training and prediction efficiency, accuracy measurement and other functions.",source:"@site/versioned_docs/version-0.2.x/advanced-guides/Base Classes Reference/csa/Classifier.md",sourceDirName:"advanced-guides/Base Classes Reference/csa",slug:"/advanced-guides/Base Classes Reference/csa/Classifier",permalink:"/ais-package.github.io/docs/advanced-guides/Base Classes Reference/csa/Classifier",draft:!1,tags:[],version:"0.2.x",lastUpdatedBy:"Jo\xe3o Paulo",lastUpdatedAt:1744077924,formattedLastUpdatedAt:"Apr 8, 2025",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Artificial Immune Recognition System Base",sidebar_label:"Artificial Immune Recognition System",lastUpdatedAt:"2025/04/07",author:"Jo\xe3o Paulo"},sidebar:"tutorialSidebar",previous:{title:"Clonal Selection Algorithms",permalink:"/ais-package.github.io/docs/category/clonal-selection-algorithms"},next:{title:"Metrics",permalink:"/ais-package.github.io/docs/advanced-guides/Utils/Metrics"}},s={},c=[{value:"Function score(...)",id:"function-score",level:3},{value:"Protected Functions:",id:"protected-functions",level:2},{value:"Function _distance(...):",id:"function-_distance",level:3},{value:"Function _check_and_raise_exceptions_fit(...):",id:"function-_check_and_raise_exceptions_fit",level:3},{value:"Function fit(...)",id:"function-fit",level:3},{value:"Returns:",id:"returns",level:2},{value:"Function predict(...)",id:"function-predict",level:3}],p={toc:c},u="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"baseclassifier"},"BaseClassifier"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"BaseClassifier")," class contains utility functions with the ",(0,r.kt)("inlineCode",{parentName:"p"},"protected")," modifier that can be inherited by various classes for ease of use. It includes functions for distance calculation, data separation to improve training and prediction efficiency, accuracy measurement and other functions."),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"function-score"},"Function score(...)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def _score(self, X: npt.NDArray, y: list) -> float\n")),(0,r.kt)("p",null,"Score function calculates forecast accuracy."),(0,r.kt)("p",null,"This function performs the prediction of X and checks how many elements are equal between vector y and y_predicted.\nThis function was added for compatibility with some scikit-learn functions."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"X"))," ",(0,r.kt)("inlineCode",{parentName:"li"},"np.ndarray"),":\nFeature set with shape (n_samples, n_features)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"y"))," ",(0,r.kt)("inlineCode",{parentName:"li"}," np.ndarray"),":\nTrue values with shape (n_samples,).")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"accuracy ",(0,r.kt)("inlineCode",{parentName:"li"},"float"),":\nThe accuracy of the model.")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"This score uses the ",(0,r.kt)("a",{parentName:"p",href:"/docs/advanced-guides/Utils/Metrics#function-accuracy_score"},(0,r.kt)("strong",{parentName:"a"},"accuracy_score"))," function.")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"protected-functions"},"Protected Functions:"),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"function-_distance"},"Function _distance(...):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def _distance(self, u: npt.NDArray, v: npt.NDArray)\n")),(0,r.kt)("p",null,"Function to calculate the distance between two points by the chosen ",(0,r.kt)("inlineCode",{parentName:"p"},"metric"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"u"))," (",(0,r.kt)("inlineCode",{parentName:"li"},"npt.NDArray"),"): Coordinates of the first point."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"v"))," (",(0,r.kt)("inlineCode",{parentName:"li"},"npt.NDArray"),"): Coordinates of the second point.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Distance (",(0,r.kt)("inlineCode",{parentName:"li"},"double"),") between the two points.")),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"function-_check_and_raise_exceptions_fit"},"Function _check_and_raise_exceptions_fit(...):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'def _check_and_raise_exceptions_fit(\n    X: npt.NDArray = None,\n    y: npt.NDArray = None,\n    algorithm: Literal[\n        "continuous-features", "binary-features"\n    ] = "continuous-features"\n)\n')),(0,r.kt)("p",null,"Function responsible for verifying fit function parameters and throwing exceptions if the verification is not successful."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"X"))," (",(0,r.kt)("inlineCode",{parentName:"li"},"npt.NDArray"),"): Training array, containing the samples and their characteristics, ","[",(0,r.kt)("inlineCode",{parentName:"li"},"N samples")," (rows)][``N features`` (columns)]","."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"y"))," (",(0,r.kt)("inlineCode",{parentName:"li"},"npt.NDArray"),"): Array of target classes of ",(0,r.kt)("inlineCode",{parentName:"li"},"X")," with ","[",(0,r.kt)("inlineCode",{parentName:"li"},"N samples")," (lines)]","."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"algorithm"))," (algorithm: Literal",'["continuous-features", "binary-features"]',", optional): Current algorithm. Defaults to 'continuous-features'.")),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"function-fit"},"Function fit(...)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"@abstractmethod\ndef fit(self, X: npt.NDArray, y: npt.NDArray, verbose: bool = True)\n")),(0,r.kt)("p",null,"Function to train the model using the input data ",(0,r.kt)("inlineCode",{parentName:"p"},"X")," and corresponding labels ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"."),(0,r.kt)("p",null,"This abstract method is implemented by the class that inherits it."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Parameters:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"X"))," (",(0,r.kt)("inlineCode",{parentName:"li"},"npt.NDArray"),"): Input data used for training the model, previously normalized to the range ","[0, 1]","."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"y"))," (",(0,r.kt)("inlineCode",{parentName:"li"},"npt.NDArray"),"): Corresponding labels or target values for the input data."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"verbose"))," (",(0,r.kt)("inlineCode",{parentName:"li"},"bool"),", optional): Flag to enable or disable detailed output during \\\ntraining. Default is ",(0,r.kt)("inlineCode",{parentName:"li"},"True"),".")),(0,r.kt)("h2",{id:"returns"},"Returns:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"self"),": Returns the instance of the class that implements this method.")),(0,r.kt)("p",null,"Implementation:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/aisp-techniques/Clonal%20Selection%20Algorithms/AIRS/#function-fit"},"AIRS"))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"function-predict"},"Function predict(...)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"@abstractmethod\ndef predict(self, X) -> Optional[npt.NDArray]\n")),(0,r.kt)("p",null,"Function to generate predictions based on the input data ",(0,r.kt)("inlineCode",{parentName:"p"},"X"),"."),(0,r.kt)("p",null,"This abstract method is implemented by the class that inherits it."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Parameters:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"X"))," (",(0,r.kt)("inlineCode",{parentName:"li"},"npt.NDArray"),"): Input data for which predictions will be generated.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"Predictions"))," (",(0,r.kt)("inlineCode",{parentName:"li"},"Optional[npt.NDArray]"),"): Predicted values for each input sample, or ",(0,r.kt)("inlineCode",{parentName:"li"},"None")," if the prediction fails.")),(0,r.kt)("p",null,"Implementation:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/aisp-techniques/Clonal%20Selection%20Algorithms/AIRS/#function-predict"},"AIRS"))))}d.isMDXComponent=!0}}]);